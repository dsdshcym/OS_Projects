#+TITLE: A Simple Shell Implementation
#+AUTHOR: 陈一鸣

* Abstract
This is a simple shell implementation. The basic functions are defined in
/Operating System Concepts Ninth Edition/[fn:1], Chapter 3, Project 1. Which
means, this shell can execute one single command given by user, can run commands
in the background and have some basic history methods. And I borrowed some
concepts from the xv6's shell implementation and added readline library to give
a more advanced input experience for users.
* Project Requiements
In my humble opinion, there are three different kinds of shells baced on what
kind of commands they can handle.

1. Shells that can execute one single command given by user.

   #+BEGIN_SRC sh
     ls
     cd ..
     mv
     mkdir
     ls &
     history
     !!
     !N
   #+END_SRC

2. Shells that can execute multiple commands in one line, pipeline commands and etc.

   #+BEGIN_SRC sh
     ls && cd ..
     ls & cd ..
     ls -all | grep
   #+END_SRC

3. Shells that can execute shell scripts. Such as bash, zsh, fish and etc.

According to the text book, this project only needs us to implement the first
one and has two parts. And the shell needs some basic error handling functions
for sure.

- Part 1 ::
     Use =fork()=, =execvp()= and =wait()= to fork a child progress, execute the
     command specified by user and determine whether to wait for it by the '&'
     character.
- Part 2 ::
     Add a command named =history=, which can list the command history as the
     following example showed:

     #+BEGIN_EXAMPLE
       6 ps
       5 ls -l
       4 top
       3 cal
       2 who
       1 date
     #+END_EXAMPLE

     Support two methods for retrieving commands from the history:

     #+BEGIN_SRC sh
       !! # Execute the last command
       !N # Execute the Nth command
     #+END_SRC
* Basic Design
I thought the later two kinds of shell are beyond my personal ability. Since
they all needs some kind of syntax analysis knowledge. So I decided to just
implement Part 1 and 2 with some enhancements.
** Type Definitions
As we all know, C language is not a Object-Oriented Programming Language. But we
can still use =struct= to get some features, such as inheritance and
polymorphism. I learned this from the shell implement in xv6.

So I made several structs for commands from the very first time.

1. =cmd=, the basic struct which contains command type and a boolean variable
   indicates whether this command includes a '&' character.

   #+BEGIN_SRC c
     struct cmd {
         int type;
         int include_ampersand;
     };
   #+END_SRC

2. =execCmd=, the most common command. Such as =mkdir=, =mv=, =cp= and etc.
   Which we can directly call =execvp= to execute this command.

   #+BEGIN_SRC c
     struct execCmd {
         int type;
         int include_ampersand;
         char *args[MAX_LINE / 2 + 1];
     };
   #+END_SRC

3. =exitCmd=, this command type is for a specific command named =exit=, which
   will set the =should_run= variable to 0 and thus cause the osh program exit.

   #+BEGIN_SRC c
     struct exitCmd {
         int type;
         int include_ampersand;
         char *args[MAX_LINE / 2 + 1];
     };
   #+END_SRC

4. =cdirCmd=, this command type is for a specific command named =cd=, which will
   change the working directory of the current osh progress. If we create a
   child thread and change the working directory in the child progress, it will
   not affect the parent thread. So we need to make =cd= a built-in command of
   the osh.

   #+BEGIN_SRC c
     struct cdirCmd {
         int type;
         int include_ampersand;
         char *args[MAX_LINE / 2 + 1];
     };
   #+END_SRC

5. =execHisCmd=, this command type is for commands related to command history.
   Such as =history=, =!!= and =!N=.

   #+BEGIN_SRC c
     struct execHisCmd {
         int type;
         int include_ampersand;
         char *args[MAX_LINE / 2 + 1];
     };
   #+END_SRC

I have to admit that I didn't use the most power of polymorphism in this
project. As you can see, these types are almost the same. But it's convenient
for us to add some more complicated commands such as pipeline commands if we
make some prepare for them.
* Footnotes

[fn:1] Galvin P B, Gagne G, Silberschatz A. Operating system concepts[M]. John Wiley & Sons, Inc., 2013.
